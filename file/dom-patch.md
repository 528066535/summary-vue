## patch

虚拟DOM的核心部分，也是大家常说的diff算法所在的部分。

### patch介绍

#### patch的作用是什么？

实际上patch方法调用是在watch到具体状态发生了变化，需要更新视图的时候。所以，patch所做的事情是最大限度的优化虚拟DOM的速度，并且渲染成真实
的DOM。

通过名称我们知道，patch是补丁，修补的意思，所以他并不是直接暴力更新整个DOM，而是通过对比新旧两个虚拟节点的区别，去更新不同的地方。

我们知道在javascript的运算速度比DOM渲染速度要快的多的多，所以我们可以通过虚拟DOM的对比方法，用JS先把虚拟DOM计算好，再渲染应该渲染的地方，
达到优化性能的目的。

#### patch都做了什么事情？

那具体的我们是如何通过对比两个虚拟DOM的差异，来修改真实的DOM呢？

实际上patch只对真实的DOM做了三件事：

* 创建新增的节点。
* 删除废弃的节点。
* 修改更新的节点。

接下来会具体套路这三件事情。

### 新增节点

#### 什么情况下会新增节点？

正常情况下，新增节点会发生在两种条件下。

第一就是当vnode存在而oldVnode不存在时，这种情况发生在首次渲染的时候，此时没有oldVnode，这时候需要直接用vnode来渲染。

第二种情况是当vnode和oldVnode是完全不相同的一个节点，这种情况可以看出vnode是全新的一个节点，需要用全新的vnode替换旧的oldVnode，
而此时oldVnode则需要被废弃。

#### 新增节点的过程

在实际情况中，只有三类VNode的实例才会新增节点，分别是：元素节点、注释节点和文本节点。

当需要创建元素节点的时候，VUE会根据vnode的描述，用当前环境下的createElement方法（在浏览器中就是document.createElement）来创建真实的DOM
节点。创建成功后再插入父节点中，此时调用当前环境的appendChild（在浏览器中就是parentNode.createElement）.

而vnode会有children属性，他保存了子节点的信息，children属性有值的时候，我们还必须把子节点遍历并插入到刚刚提到的vnode中，再将vnode插入到
父节点中。

当需要创建注释阶段或者文本节点的时候，则调用createTextNode或者createComment方法。

### 删除节点

#### 什么情况下会删除节点

新增节点的第二种情况下，当老的节点和新的节点是完全不同的节点的时候，会新增节点，相应的也会删除老的被废弃的节点。

### 更新节点

#### 什么情况下会更新节点

不管是新增还是删除节点，两个新旧的节点都是完全不同的，而当新旧两个节点是同一个节点时，就需要通过更细致的对比，再对老的节点进行更新了。

#### 更新节点的过程

首先如果需要更新的节点是静态节点，则直接跳过不更新。什么是静态节点呢？静态节点就是那些不会发生变化的节点，比如<p></p> 这部分不会发生变化。

然后，如果需要更新的节点有文本属性的话，则会和旧的节点对比，如果和旧的节点不同，则直接设置文本，不需要在乎旧的节点是否有子元素或者其他情况。

接下来，如果需要更新的节点没有文本属性，说明这个节点内可能是空，或者有元素节点，如果是空，则直接把旧的节点内所有东西删除，如果不为空，则对
vnode和oldVnode的children进行对比。这部分就是子节点的对比了。

#### 子节点

子节点大致上分为四种操作：创建节点，删除节点，更新节点，移动节点。

创建节点我们需要知道什么情况下创建，以及创建的节点的位置，我们知道vnode和oldVnode的children会循环对比，当oldVnode循环结束后，并没有
找到相同的节点，说明这个节点是新的节点此时需要新增节点。

![构建图](/img/虚拟DOM.jpg)

而新增的位置就是旧节点第一个未处理节点的前面，毕竟我们是以oldVnode为基准进行增删改移动的操作。如果是以已处理的最后一个，那么当新增第二个
节点的时候，oldVnode已处理的节点还在新增节点的前面。如上图，如果第四个节点也是新增的时候。

#### 更新子节点

当两个子节点是同一节点，并且位置相同，则只需要更新子节点，过程过更新节点的过程相同。

如果位置不相同的话，除了更新节点，还需要移动节点。

#### 移动子节点

移动子节点的位置和新增节点一样，都是把节点移动到未处理节点前。

#### 删除字节点

当vnode所有的节点都循环完毕，oldVnode未处理的节点都是需要删除的节点了。

### 节点的循环优化

在很多时候，我们发现很多的DOM有时候位置可能变化不大，或者倒序了下而已，如果只是机械的循环，反而增加了循环次数，于是有了四种快捷查询方式：

* vnode的第一个未处理节点与oldVnode第一个未处理节点相比较
* vnode的最后一个未处理节点与oldVnode第一个未处理节点相比较
* vnode的第一个未处理节点和oldVnode最后一个未处理节点相比较
* vnode的最后一个未处理节点和oldVnode最后一个未处理节点相比较

这四个判断算一轮判断，判断完成后，就可以设置对应的节点为已处理，然后再次进入上面的循环。

#### 那我们具体怎么判断哪些节点已经处理了，哪些节点没有处理呢？

首先我们需要四个参数，oldStartIdx、oldEndIdx、newStartIdx、newEndIdx，对应的是新旧虚拟dom的四个位置。

其次，开始对比，比如新的第一个未处理节点与旧的第一个未处理节点相同，则更新，然后再将oldStartIdx和newStartIdx同时向后移动一个单位，
如果新的最后一个未处理节点与旧的第一个未处理节点相同，则需要把旧的第一个未处理节点移动到最后一个位置形成最新的节点，这个过程中，新旧的节点
不需要变化，变化的只是最新的那个节点，并且把newEndIdx减少一个单位，oldStartIdx增加一个单位。其他节点都是类似的做法

最后我们发现 oldStartIdx<=oldEndIdx 并且 newStartIdx<=newEndIdx才会执行这个循环，当这个条件不成立的时候，就会结束，而结束的时候，可能
会遇到旧的节点有多余，或者新的节点有多余的，而多余的节点则不需要再次循环，达到节省性能的目的，如果旧的多余，说明是废弃的节点，直接删除就好，
如果是新的节点多余，则说明是新增的节点，直接添加到DOM中就好了。

### 总结

在学习整个patch的过程，我们再走了一遍虚拟DOM要走的路，首先新旧两个节点对比，如果是完全不同的节点则需要新增或者删除，如果是相同的节点，
则需要更新，注释节点和文本节点直接更新，否则则是元素节点，如果元素节点为空，则直接删除旧元素节点中所有内容，如果不为空，则需要进行子节点的对比，
而子节点的对比，用到了diff算法。子节点的对比循环是通过新前新后，和久前旧后的循环对比完成的，对比的过程中可能会遇到四种操作，包括增，删，改，
移，而循环则是通过控制四个位置来实现的。
